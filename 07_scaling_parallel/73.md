# 7.3 远程分块(Remote Chunking)

远程分块的Step被拆分成多个进程处理,通过中间件实现彼此通信. 下面是一幅模型示意图:

![remote-chunking](./remote-chunking.png)


The Master component is a single process, and the Slaves are multiple remote processes. Clearly this pattern works best if the Master is not a bottleneck, so the processing must be more expensive than the reading of items (this is often the case in practice).

主组件是一个单一的过程,和奴隶是多个远程过程。显然这种模式效果最好,如果主不是一个瓶颈,因此处理必须比阅读更昂贵的物品(这在实践中是常有的事)。

The Master is just an implementation of a Spring Batch **Step**, with the ItemWriter replaced with a generic version that knows how to send chunks of items to the middleware as messages. The Slaves are standard listeners for whatever middleware is being used (e.g. with JMS they would be **MesssageListeners**), and their role is to process the chunks of items using a standard **ItemWriter** or **ItemProcessor** plus **ItemWriter**, through the **ChunkProcessor** interface. One of the advantages of using this pattern is that the reader, processor and writer components are off-the-shelf (the same as would be used for a local execution of the step). The items are divided up dynamically and work is shared through the middleware, so if the listeners are all eager consumers, then load balancing is automatic.

Spring Batch的主只是一个实现* * * *的一步,ItemWriter替换为通用版本,知道如何发送块项目中间件的消息。奴隶是标准的听众无论使用中间件(例如JMS他们将* * MesssageListeners * *),和他们的作用是处理大量物品使用标准* * ItemWriter * *或* * ItemProcessor * *和* * ItemWriter * *,在* * ChunkProcessor * *接口。使用此模式的优点之一是,读者,处理器和作家组件是现成的(将用于当地执行相同的步骤)。项目动态划分和工作通过中间件是共享的,因此,如果听众都急切的消费者,则自动负载平衡。

The middleware has to be durable, with guaranteed delivery and single consumer for each message. JMS is the obvious candidate, but other options exist in the grid computing and shared memory product space (e.g. Java Spaces).

中间件必须耐用,保证每个消息交付和单一的消费者。JMS是明显的候选人,但其他选项存在于网格计算和产品共享内存空间(例如Java空间)。


