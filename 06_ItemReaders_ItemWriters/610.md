# 6.10 Reusing Existing Services #

Batch systems are often used in conjunction with other application styles. The most common is an online system, but it may also support integration or even a thick client application by moving necessary bulk data that each application style uses. For this reason, it is common that many users want to reuse existing DAOs or other services within their batch jobs. The Spring container itself makes this fairly easy by allowing any necessary class to be injected. However, there may be cases where the existing service needs to act as an **ItemReader** or **ItemWriter**, either to satisfy the dependency of another Spring Batch class, or because it truly is the main **ItemReader** for a step. It is fairly trivial to write an adaptor class for each service that needs wrapping, but because it is such a common concern, Spring Batch provides implementations: **ItemReaderAdapter** and **ItemWriterAdapter**. Both classes implement the standard Spring method invoking the delegate pattern and are fairly simple to set up. Below is an example of the reader:

批处理系统通常与其他应用程序结合使用样式。最常见的是一个在线系统,但它也支持集成甚至通过必要的批量数据使用一个瘦客户端应用程序,每个应用程序样式使用。由于这个原因,它是很常见的,许多用户想要重用现有的dao或其他服务在批处理作业。Spring容器本身会使这个相当容易,允许任何必要的类被注入。然而,可能的情况下,现有的服务需要作为一个* * ItemReader * *或* * ItemWriter * *,要么满足另一个Spring Batch类的依赖,或因为它真正是一个步骤的主要* * ItemReader * *。它是相当容易编写一个适配器类为每个服务需要包装,而是因为它是这样一个共同关心,Spring Batch提供了实现:* * ItemReaderAdapter * *和* * ItemWriterAdapter * *。两类实现标准弹簧方法调用委托模式和设置相当简单。下面是一个示例的读者:


	<bean id="itemReader" class="org.springframework.batch.item.adapter.ItemReaderAdapter">
	    <property name="targetObject" ref="fooService" />
	    <property name="targetMethod" value="generateFoo" />
	</bean>
	
	<bean id="fooService" class="org.springframework.batch.item.sample.FooService" />


One important point to note is that the contract of the targetMethod must be the same as the contract for **read**: when exhausted it will return null, otherwise an **Object**. Anything else will prevent the framework from knowing when processing should end, either causing an infinite loop or incorrect failure, depending upon the implementation of the **ItemWriter**. The **ItemWriter** implementation is equally as simple:

特别需要注意的是, targetMethod 必须和 **read** 中的方法名称一致: 如果不存在则返回null, 否则一个* *的* *对象。任何别的办法能阻止这个框架应该知道什么时候处理结束,导致无限循环或不正确的失败,根据* * ItemWriter * *的实现。* * ItemWriter * *实现同样简单:


	<bean id="itemWriter" class="org.springframework.batch.item.adapter.ItemWriterAdapter">
	    <property name="targetObject" ref="fooService" />
	    <property name="targetMethod" value="processFoo" />
	</bean>
	
	<bean id="fooService" class="org.springframework.batch.item.sample.FooService" />
