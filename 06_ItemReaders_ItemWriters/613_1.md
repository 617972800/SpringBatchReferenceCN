## 6.13.1 自定义 ItemReader 示例 ##


为了实现这个目的,我们实现一个简单的 `ItemReader`, 从给定的list中读取数据。 我们将实现最基本的 *ItemReader* 功能, read:


	public class CustomItemReader<T> implements ItemReader<T>{
	
	    List<T> items;
	
	    public CustomItemReader(List<T> items) {
	        this.items = items;
	    }
	
	    public T read() throws Exception, UnexpectedInputException,
	       NoWorkFoundException, ParseException {
	
	        if (!items.isEmpty()) {
	            return items.remove(0);
	        }
	        return null;
	    }
	}


这是一个简单的类, 传入一个 items list, 每次读取时删除其中的一条并返回。 如果list里面没有内容,则将返回null, 从而满足 `ItemReader` 的基本要求, 测试代码如下所示:


	List<String> items = new ArrayList<String>();
	items.add("1");
	items.add("2");
	items.add("3");
	
	ItemReader itemReader = new CustomItemReader<String>(items);
	assertEquals("1", itemReader.read());
	assertEquals("2", itemReader.read());
	assertEquals("3", itemReader.read());
	assertNull(itemReader.read());


**使得 *ItemReader* 支持重启**

The final challenge now is to make the *ItemReader* restartable. Currently, if the power goes out, and processing begins again, the *ItemReader* must start at the beginning. This is actually valid in many scenarios, but it is sometimes preferable that a batch job starts where it left off. The key discriminant is often whether the reader is stateful or stateless. A stateless reader does not need to worry about restartability, but a stateful one has to try and reconstitute its last known state on restart. For this reason, we recommend that you keep custom readers stateless if possible, so you don't have to worry about restartability.

现在最后的挑战是让* ItemReader *可重新开始的。目前,如果停电的情况,再次和处理开始,* ItemReader *必须从头开始。这实际上是有效的在很多情况下,但它有时是可取的,批处理作业开始离开。关键判别往往是读者是否有状态的和无状态的。无状态的读者不需要担心再启动,但一个有状态的人,试图重建其最后一个已知状态重新启动。出于这个原因,我们建议您保持定制读者无状态如果可能,所以你不必担心再启动。


如果需要保存状态信息,那应该使用 `ItemStream` 接口:

	public class CustomItemReader<T> implements ItemReader<T>, ItemStream {
	
	    List<T> items;
	    int currentIndex = 0;
	    private static final String CURRENT_INDEX = "current.index";
	
	    public CustomItemReader(List<T> items) {
	        this.items = items;
	    }
	
	    public T read() throws Exception, UnexpectedInputException,
	        ParseException {
	
	        if (currentIndex < items.size()) {
	            return items.get(currentIndex++);
	        }
	
	        return null;
	    }
	
	    public void open(ExecutionContext executionContext) throws ItemStreamException {
	        if(executionContext.containsKey(CURRENT_INDEX)){
	            currentIndex = new Long(executionContext.getLong(CURRENT_INDEX)).intValue();
	        }
	        else{
	            currentIndex = 0;
	        }
	    }
	
	    public void update(ExecutionContext executionContext) throws ItemStreamException {
	        executionContext.putLong(CURRENT_INDEX, new Long(currentIndex).longValue());
	    }
	
	    public void close() throws ItemStreamException {}
	}

On each call to the *ItemStream* update method, the current index of the *ItemReader* will be stored in the provided *ExecutionContext* with a key of 'current.index'. When the *ItemStream* open method is called, the *ExecutionContext* is checked to see if it contains an entry with that key. If the key is found, then the current index is moved to that location. This is a fairly trivial example, but it still meets the general contract:

在每个调用* ItemStream *更新方法,当前指数* ItemReader *将存储*的ExecutionContext *提供了一个关键的“current.index”。* ItemStream *开放的方法被调用时,该*的ExecutionContext *检查,看它是否与该密钥包含一个条目。如果找到的关键,那么当前指数移动到该位置。这是一个相当简单的例子,但它仍然满足总承包合同:


	ExecutionContext executionContext = new ExecutionContext();
	((ItemStream)itemReader).open(executionContext);
	assertEquals("1", itemReader.read());
	((ItemStream)itemReader).update(executionContext);
	
	List<String> items = new ArrayList<String>();
	items.add("1");
	items.add("2");
	items.add("3");
	itemReader = new CustomItemReader<String>(items);
	
	((ItemStream)itemReader).open(executionContext);
	assertEquals("2", itemReader.read());


大多数ItemReaders具有更加复杂的重启逻辑。 例如 **JdbcCursorItemReader** , 存储了游标(Cursor)中最后所处理的行的 row id。


It is also worth noting that the key used within the *ExecutionContext* should not be trivial. That is because the same *ExecutionContext* is used for all *ItemStreams* within a *Step*. In most cases, simply prepending the key with the class name should be enough to guarantee uniqueness. However, in the rare cases where two of the same type of *ItemStream* are used in the same step (which can happen if two files are need for output) then a more unique name will be needed. For this reason, many of the Spring Batch *ItemReader* and ItemWriter implementations have a *setName()* property that allows this key name to be overridden.

它也是值得注意的关键*的ExecutionContext *中使用不应简单。这是因为用于所有相同的*的ExecutionContext * * ItemStreams * * *内一步。在大多数情况下,通过类名追加的关键应该足以保证唯一性。然而,在罕见的情况下,两个相同类型的* ItemStream *用于相同的步骤(如果两个文件需要输出)需要更多的惟一名称。出于这个原因,许多Spring Batch * ItemReader *和ItemWriter实现* setName()*属性,允许这个关键的名字被覆盖。

